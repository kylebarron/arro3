from typing import Sequence
from numpy.typing import NDArray

from .types import (
    ArrowArrayExportable,
    ArrowSchemaExportable,
    ArrowStreamExportable,
    FieldIndexInput,
    MetadataInput,
)

class Array:
    def __array__(self) -> NDArray: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> tuple[object, object]: ...
    def __eq__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Array: ...
    @classmethod
    def from_arrow_pycapsule(cls, schema_capsule, array_capsule) -> Array: ...
    def to_numpy(self) -> NDArray: ...
    def slice(self, offset: int = 0, length: int | None = None) -> Array: ...
    @property
    def type(self) -> DataType: ...

class ArrayReader:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowStreamExportable) -> ArrayReader: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> ArrayReader: ...
    @classmethod
    def from_arrays(
        cls, schema: ArrowSchemaExportable, arrays: Sequence[ArrowArrayExportable]
    ) -> ArrayReader: ...
    @classmethod
    def from_stream(cls, data: ArrowStreamExportable) -> ArrayReader: ...
    @property
    def closed(self) -> bool: ...
    def read_all(self) -> ChunkedArray: ...
    def read_next_array(self) -> Array: ...
    def field(self) -> Field: ...

class ChunkedArray:
    def __init__(
        self,
        arrays: Sequence[ArrowArrayExportable],
        type: ArrowSchemaExportable | None = None,
    ) -> None: ...
    def __array__(self) -> NDArray: ...
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowStreamExportable) -> ChunkedArray: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> ChunkedArray: ...
    def chunk(self, i: int) -> Array: ...
    @property
    def chunks(self) -> list[Array]: ...
    def combine_chunks(self) -> Array: ...
    def equals(self, other: ArrowStreamExportable) -> bool: ...
    def length(self) -> int: ...
    @property
    def null_count(self) -> int: ...
    @property
    def num_chunks(self) -> int: ...
    def slice(self, offset: int = 0, length: int | None = None) -> ChunkedArray: ...
    def to_numpy(self) -> NDArray: ...
    @property
    def type(self) -> DataType: ...

class DataType:
    def __arrow_c_schema__(self) -> object: ...
    def __eq__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowSchemaExportable) -> DataType: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> DataType: ...
    def bit_width(self) -> int | None: ...

class Field:
    def __init__(
        self,
        name: str,
        type: ArrowSchemaExportable,
        nullable: bool = True,
        *,
        metadata: MetadataInput | None = None,
    ) -> None: ...
    def __arrow_c_schema__(self) -> object: ...
    def __eq__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowSchemaExportable) -> Field: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> Field: ...
    def equals(self, other: ArrowSchemaExportable) -> bool: ...
    @property
    def metadata(self) -> dict[bytes, bytes]: ...
    @property
    def metadata_str(self) -> dict[str, str]: ...
    @property
    def name(self) -> str: ...
    @property
    def nullable(self) -> bool: ...
    def remove_metadata(self) -> Field: ...
    @property
    def type(self) -> DataType: ...
    def with_metadata(self, metadata: MetadataInput) -> Field: ...
    def with_name(self, name: str) -> Field: ...
    def with_nullable(self, nullable: bool) -> Field: ...
    def with_type(self, new_type: ArrowSchemaExportable) -> Field: ...

class RecordBatch:
    def __init__(
        self,
        data: ArrowArrayExportable | dict[str, ArrowArrayExportable],
        *,
        metadata: ArrowSchemaExportable | None = None,
    ) -> None: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> tuple[object, object]: ...
    def __eq__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrays(
        cls, arrays: Sequence[ArrowArrayExportable], *, schema: ArrowSchemaExportable
    ) -> RecordBatch: ...
    @classmethod
    def from_pydict(
        cls,
        mapping: dict[str, ArrowArrayExportable],
        *,
        metadata: ArrowSchemaExportable | None = None,
    ) -> RecordBatch: ...
    @classmethod
    def from_struct_array(cls, struct_array: ArrowArrayExportable) -> RecordBatch: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> RecordBatch: ...
    @classmethod
    def from_arrow_pycapsule(cls, schema_capsule, array_capsule) -> RecordBatch: ...
    def add_column(
        self, i: int, field: ArrowSchemaExportable, column: ArrowArrayExportable
    ) -> RecordBatch: ...
    def append_column(
        self, field: ArrowSchemaExportable, column: ArrowArrayExportable
    ) -> RecordBatch: ...
    def column(self, i: int) -> ChunkedArray: ...
    @property
    def column_names(self) -> list[str]: ...
    @property
    def columns(self) -> list[Array]: ...
    def equals(self, other: ArrowArrayExportable) -> bool: ...
    def field(self, i: int) -> Field: ...
    @property
    def num_columns(self) -> int: ...
    @property
    def num_rows(self) -> int: ...
    def remove_column(self, i: int) -> RecordBatch: ...
    @property
    def schema(self) -> Schema: ...
    def select(self, columns: list[int]) -> RecordBatch: ...
    def set_column(
        self, i: int, field: ArrowSchemaExportable, column: ArrowArrayExportable
    ) -> RecordBatch: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    def slice(self, offset: int = 0, length: int | None = None) -> RecordBatch: ...
    def to_struct_array(self) -> Array: ...
    def with_schema(self, schema: ArrowSchemaExportable) -> RecordBatch: ...

class RecordBatchReader:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowStreamExportable) -> RecordBatchReader: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> RecordBatchReader: ...
    @classmethod
    def from_batches(
        cls, schema: ArrowSchemaExportable, batches: Sequence[ArrowArrayExportable]
    ) -> RecordBatchReader: ...
    @classmethod
    def from_stream(cls, data: ArrowStreamExportable) -> RecordBatchReader: ...
    @property
    def closed(self) -> bool: ...
    def read_all(self) -> Table: ...
    def read_next_batch(self) -> RecordBatch: ...
    def schema(self) -> Schema: ...

class Schema:
    def __init__(
        self,
        fields: Sequence[ArrowSchemaExportable],
        *,
        metadata: MetadataInput | None = None,
    ) -> None: ...
    def __arrow_c_schema__(self) -> object: ...
    def __eq__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowSchemaExportable) -> Schema: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> Schema: ...
    def append(self, field: ArrowSchemaExportable) -> Schema: ...
    def empty_table(self) -> Table: ...
    def equals(self, other: ArrowSchemaExportable) -> bool: ...
    def field(self, i: FieldIndexInput) -> Field: ...
    def get_all_field_indices(self, name: str) -> list[int]: ...
    def get_field_index(self, name: str) -> int: ...
    def insert(self, i: int, field: ArrowSchemaExportable) -> Schema: ...
    @property
    def metadata(self) -> dict[bytes, bytes]: ...
    @property
    def metadata_str(self) -> dict[str, str]: ...
    @property
    def names(self) -> list[str]: ...
    def remove(self, i: int) -> Schema: ...
    def remove_metadata(self) -> Schema: ...
    def set(self, i: int, field: ArrowSchemaExportable) -> Schema: ...
    @property
    def types(self) -> list[DataType]: ...
    def with_metadata(self, metadata: MetadataInput) -> Schema: ...

class Table:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    @classmethod
    def from_arrow(cls, input: ArrowStreamExportable) -> Table: ...
    @classmethod
    def from_arrow_pycapsule(cls, capsule) -> Table: ...
    def add_column(
        self, i: int, field: ArrowSchemaExportable, column: ArrowStreamExportable
    ) -> RecordBatch: ...
    def append_column(
        self, field: ArrowSchemaExportable, column: ArrowStreamExportable
    ) -> RecordBatch: ...
    @property
    def chunk_lengths(self) -> list[int]: ...
    def column(self, i: int) -> ChunkedArray: ...
    @property
    def column_names(self) -> list[str]: ...
    @property
    def columns(self) -> list[ChunkedArray]: ...
    def combine_chunks(self) -> Table: ...
    def field(self, i: FieldIndexInput) -> Field: ...
    @property
    def num_columns(self) -> int: ...
    @property
    def num_rows(self) -> int: ...
    def set_column(
        self, i: int, field: ArrowSchemaExportable, column: ArrowStreamExportable
    ) -> Table: ...
    @property
    def schema(self) -> Schema: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    def to_batches(self) -> list[RecordBatch]: ...
    def to_reader(self) -> RecordBatchReader: ...
    def to_struct_array(self) -> ChunkedArray: ...
    def with_schema(self, schema: ArrowSchemaExportable) -> Table: ...
